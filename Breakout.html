<html>

<canvas id = "gameCanvas" width = "800" height = "600"></canvas>

<script type = "text/javascript">
var canvas;
var canvasContext;
var fps = 30;

var ballX;
var ballY;
var ballSpeedX = 2;
var ballSpeedY = 2;
var ballRadius = 10;
var ballOffsetX = 0;
var ballOffsetY = -50;

var score = 0;

var paddleX;
var paddleY;
var paddleHeight = 10;
var paddleWidth = 100;
var paddleSpeed = 10;
var paddleOffsetX = 0;
var paddleOffsetY = 0;

var numRows = 4;
var numCols = 5;
var blockSpaceX = 10;
var blockSpaceY = 10;
var blockHeight = 30;
var blockWidth = 20;
var leftSpace = 10;
var rightSpace = 10;
var upSpace = 20;

class Block {
	constructor(left, top, width, height, color) {
		this.left = left;
		this.top = top;
		this.width = width;
		this.height = height;
		this.color = color;
		this.isBroken = false;
		this.checkOffset = 100;
	}
	draw() {
		if (!this.isBroken) {
			colorRect(this.left, this.top, this.width, this.height, this.color);
		}
	}
	checkNearBall() {
		return Math.abs(ballX - this.left + this.width / 2) <= this.checkOffset && Math.abs(ballY - this.top + this.height / 2) <= this.checkOffset;
	}
	collideBall() {
    		var dx;
	    	var dy;
		var right;
		var below;
		if (ball
    		var width = this.width / 2;
	    	var height = this.height / 2;
    		var crossXProp = Math.abs(dy) / width;
	    	var crossYProp = Math.abs(dx) / height;
    		var collision = 'none';
		//console.log(crossXProp, crossYProp);
	    	if (dx <= 0 && dy <= 0) {
        		if (crossXProp <= crossYProp) {
            			collision = !right ? 'left' : 'right';
        		} else {
            			collision = !below ? 'bottom' : 'top';
        		}
    		}
		//console.log(collision);
    		return (collision);
	}
}

function init() {
	//console.log('init called');
	canvas = document.getElementById('gameCanvas');
	canvasContext = canvas.getContext('2d');
	paddleX = canvas.width / 2 - paddleWidth / 2 + paddleOffsetX;
	paddleY = canvas.height - paddleHeight + paddleOffsetY;
	ballX = canvas.width / 2 + ballOffsetX;
	ballY = canvas.height - ballRadius + ballOffsetY;
	blocks = new Array(0);
	blockWidth = (canvas.width - (leftSpace + rightSpace) - (blockSpaceX * (numCols - 1))) / numCols;
	for (i = 0; i < numRows * numCols; i++) {
		blocks.push(new Block((i % numCols) * (blockWidth + blockSpaceX) + leftSpace, Math.floor(i / numCols) * (blockHeight + blockSpaceY) + upSpace, blockWidth, blockHeight, 'white')); 
	} 
	setInterval(doFrame, 1000 / fps);

	canvas.addEventListener('mousemove', handleMouseMove);
}

function handleMouseMove(e){
	//console.log('handleMouseMove called');
	var mousePos = calculateMousePos(e);
	if(mousePos.x - paddleWidth / 2 <= 0){
		paddleX = 0;
	} else if (mousePos.x + paddleWidth / 2 >= canvas.width){
		paddleX = canvas.width - paddleWidth;
	} else {
		paddleX = mousePos.x - paddleWidth / 2;
	}
}

function calculateMousePos(e) {
	//console.log('calculateMousePos called');
	var rect = canvas.getBoundingClientRect();
	var root = document.documentElement;
	var mouseX = e.clientX - rect.left - root.scrollLeft;
	var mouseY = e.clientY - rect.top - root.scrollTop;
	return {
		x : mouseX,
		y : mouseY
	};
}

window.onload = init;

function doFrame(){
	//console.log('doFrame called');
	move();
	draw();
}

function ballReset() {
	ballX = canvas.width / 2 + ballOffsetX;
	ballY = canvas.height - ballRadius + ballOffsetY;
}

function move() {
	//console.log('move called');
	//console.log(paddleX + ', ' + paddleY);
	ballX += ballSpeedX;
	ballY += ballSpeedY;
	if (ballY + ballRadius + ballSpeedY > paddleY) {
		if (ballX + ballSpeedX > paddleX && ballX + ballSpeedX < paddleX + paddleWidth) {
			ballSpeedY *= -1;
		} else if (ballY + ballRadius + ballSpeedY > canvas.height) {
			ballReset();
		}
	}
	if (ballY - ballRadius + ballSpeedY < 0) {
		ballSpeedY *= -1;
	}
	if (ballX + ballRadius + ballSpeedX >= canvas.width || ballX - ballRadius + ballSpeedX <= 0) {
		ballSpeedX *= -1;
	}
	blocks.forEach(function(item, index, array) {
		if (!item.isBroken && item.checkNearBall()) {
			//console.log("Is near block", index);
			switch (item.collideBall()) {
				case 'left':
				case 'right':
					ballSpeedX *= -1;
					item.isBroken = true;
					break;
				case 'bottom':
				case 'up':
					ballSpeedY *= -1;
					item.isBroken = true;
					break;
			}
		}
	});
}

function draw() {
	//console.log('draw called');
	colorRect(0, 0, canvas.width, canvas.height, 'black');
	colorRect(paddleX, paddleY, paddleWidth, paddleHeight, 'white');
	colorCircle(ballX, ballY, ballRadius, 'white');
	blocks.forEach(function(item, index, array) {
		item.draw();
	});
}

function colorCircle(centerX, centerY, radius, drawColor) {
	canvasContext.fillStyle = drawColor;
	canvasContext.beginPath();
	canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
	canvasContext.fill();
}

function colorRect(leftX, topY, width, height, drawColor) {
	canvasContext.fillStyle = drawColor;
	canvasContext.fillRect(leftX, topY, width, height);
}

</script>

</html>
