<html>

<canvas id = "gameCanvas" width = "800" height = "600"></canvas>

<script type = "text/javascript">
var canvas;
var canvasContext;
var fps = 30;

var ballX;
var ballY;
var ballSpeedX = 10;
var ballSpeedY = 10;
var ballRadius = 10;
var ballOffsetX = 0;
var ballOffsetY = -50;

var score = 0;

var paddleX;
var paddleY;
var paddleHeight = 10;
var paddleWidth = 100;
var paddleSpeed = 10;
var paddleOffsetX = 0;
var paddleOffsetY = 0;

var numRows = 4;
var numCols = 5;
var blocks;
var blockSpaceX = 10;
var blockSpaceY = 10;
var blockHeight = 30;
var blockWidth = 20;
var leftSpace = 10;
var rightSpace = 10;
var upSpace = 20;

class Block {
	constructor(left, top, width, height, color) {
		this.left = left;
		this.top = top;
		this.width = width;
		this.height = height;
		this.color = color;
		this.isBroken = false;
		this.checkOffset = 100;
	}
	draw() {
		if (!this.isBroken) {
			colorRect(this.left, this.top, this.width, this.height, this.color);
		}
	}
	collideBall() {
    		if (ballX >= this.left && ballX <= this.left + this.width) {
			if (ballY + ballRadius >= this.top) {
				if (ballY + ballRadius - ballSpeedY < this.top) {
					return 'top';
				}
			}
			if (ballY - ballRadius <= this.top + this.height) {
				if (ballY - ballRadius - ballSpeedY > this.top + this.height) {
					return 'bottom';
				}
			}
		}
		if (ballY >= this.top && ballY <= this.top + this.height) {
			if (ballX + ballRadius >= this.left) {
				if (ballX + ballRadius - ballSpeedX < this.left) {
					return 'left';
				}
			}
			if (ballY - ballRadius <= this.top + this.height) {
				if (ballX - ballRadius - ballSpeedX > this.left + this.width) {
					return 'right';
				}
			}
		}
	}
}

function init() {
	//console.log('init called');
	canvas = document.getElementById('gameCanvas');
	canvasContext = canvas.getContext('2d');
	paddleX = canvas.width / 2 - paddleWidth / 2 + paddleOffsetX;
	paddleY = canvas.height - paddleHeight + paddleOffsetY;
	ballX = canvas.width / 2 + ballOffsetX;
	ballY = canvas.height - ballRadius + ballOffsetY;
	blocks = new Array(0);
	blockWidth = (canvas.width - (leftSpace + rightSpace) - (blockSpaceX * (numCols - 1))) / numCols;
	for (i = 0; i < numRows * numCols; i++) {
		blocks.push(new Block((i % numCols) * (blockWidth + blockSpaceX) + leftSpace, Math.floor(i / numCols) * (blockHeight + blockSpaceY) + upSpace, blockWidth, blockHeight, 'white')); 
	} 
	setInterval(doFrame, 1000 / fps);

	canvas.addEventListener('mousemove', handleMouseMove);
}

function handleMouseMove(e){
	//console.log('handleMouseMove called');
	var mousePos = calculateMousePos(e);
	if(mousePos.x - paddleWidth / 2 <= 0){
		paddleX = 0;
	} else if (mousePos.x + paddleWidth / 2 >= canvas.width){
		paddleX = canvas.width - paddleWidth;
	} else {
		paddleX = mousePos.x - paddleWidth / 2;
	}
}

function calculateMousePos(e) {
	//console.log('calculateMousePos called');
	var rect = canvas.getBoundingClientRect();
	var root = document.documentElement;
	var mouseX = e.clientX - rect.left - root.scrollLeft;
	var mouseY = e.clientY - rect.top - root.scrollTop;
	return {
		x : mouseX,
		y : mouseY
	};
}

window.onload = init;

function doFrame(){
	//console.log('doFrame called');
	move();
	draw();
}

function ballReset() {
	ballX = canvas.width / 2 + ballOffsetX;
	ballY = canvas.height - ballRadius + ballOffsetY;
}

function move() {
	//console.log('move called');
	//console.log(paddleX + ', ' + paddleY);
	ballX += ballSpeedX;
	ballY += ballSpeedY;
	if (ballY + ballRadius + ballSpeedY > paddleY) {
		if (ballX + ballSpeedX > paddleX && ballX + ballSpeedX < paddleX + paddleWidth) {
			ballSpeedY *= -1;
		} else if (ballY + ballRadius + ballSpeedY > canvas.height) {
			ballReset();
		}
	}
	if (ballY - ballRadius + ballSpeedY < 0) {
		ballSpeedY *= -1;
	}
	if (ballX + ballRadius + ballSpeedX >= canvas.width || ballX - ballRadius + ballSpeedX <= 0) {
		ballSpeedX *= -1;
	}
	blocks.forEach(function(item, index, array) {
		if (!item.isBroken) {
			switch (item.collideBall()) {
				case 'left':
				case 'right':
					ballSpeedX *= -1;
					item.isBroken = true;
					break;
				case 'bottom':
				case 'up':
					ballSpeedY *= -1;
					item.isBroken = true;
					break;
			}
		}
	});
}

function draw() {
	//console.log('draw called');
	colorRect(0, 0, canvas.width, canvas.height, 'black');
	colorRect(paddleX, paddleY, paddleWidth, paddleHeight, 'white');
	colorCircle(ballX, ballY, ballRadius, 'white');
	blocks.forEach(function(item, index, array) {
		item.draw();
	});
}

function colorCircle(centerX, centerY, radius, drawColor) {
	canvasContext.fillStyle = drawColor;
	canvasContext.beginPath();
	canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
	canvasContext.fill();
}

function colorRect(leftX, topY, width, height, drawColor) {
	canvasContext.fillStyle = drawColor;
	canvasContext.fillRect(leftX, topY, width, height);
}

</script>

</html>
